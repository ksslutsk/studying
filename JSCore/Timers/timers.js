//setTimeout setInterval
//вертають ідентифікатор таймера (в браузерах)
//так як специфікації на і методи не має то вони можуть працювати по різному в node.js вертається обʼєкт таймера з деякими методами
//також не гарантуються точні затримки, вони залежать від навантаженості процесора, інших задач і тд

//setTimeout
function fooTimer() {
    let timerId = setTimeout(() => console.log('timer'), 1000); //(1)
    console.log('timertask');// (2)
}

function logs() {
    console.log("task1");
    console.log("task2");
    console.log("task3");
}

logs(); //спочатку виконається ця функція 
fooTimer();//потім тут setTimeout() поставить в кінець планувальника колбек-функцію і виконається (2)
logs();//потім вик ця функція і уже після неї виконається поставиться затримка і виконається (1)

//в таймер можна передавати аргументи для колбека, їх може бути безліч (не підтриується в ie 9)
let timerId = setTimeout((i) => console.log(i), 1000, 5);//чому це виводить одразу за попереднім таймером?

//для відміни виконання використовуємо
clearTimeout(timerId);

//setInterval
//все так само як і в попередньому, тільки запускається періодично чере проміжок часу
let timerId1 = setInterval(() => {
    console.log("I'm interval!!")
}, 2000);
setTimeout(() => clearInterval(timerId1), 5000);

//також можна регулярно викликати функцію і через вкладений setTimeout
// let timerId2 = setTimeout(function tick() {
//     console.log("I'm vkladenyi setTimeout");
//     timerId2 = setTimeout(tick, 1000);
// }, 1000);
//такий спосіб більш гнучкий бо ми можемо налаштовувати таймер залежно від результатів виконання функції
//до того ж вкладений setTimeout дозволяє більш точно налаштувати затримку між виконаннями


/*
різниця між цими двома методами
setInterval запускає кожний проміжок часу, час на виконання задачі враховується
тобто якщо задача виконується 60мс а затримка 100, то між кінцем першої задачі і початком другої пройде 40мс

вкладений setTimeut гарантує точну затримку (наскільки це можливо)
*/